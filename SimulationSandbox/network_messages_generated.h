// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NETWORKMESSAGES_NETWORKSIM_H_
#define FLATBUFFERS_GENERATED_NETWORKMESSAGES_NETWORKSIM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace NetworkSim {

struct Vec3;
struct Vec3Builder;

struct ObjectUpdate;
struct ObjectUpdateBuilder;

struct GlobalState;
struct GlobalStateBuilder;

struct PeerAnnounce;
struct PeerAnnounceBuilder;

struct Message;
struct MessageBuilder;

enum MessageData : uint8_t {
  MessageData_NONE = 0,
  MessageData_ObjectUpdate = 1,
  MessageData_GlobalState = 2,
  MessageData_PeerAnnounce = 3,
  MessageData_MIN = MessageData_NONE,
  MessageData_MAX = MessageData_PeerAnnounce
};

inline const MessageData (&EnumValuesMessageData())[4] {
  static const MessageData values[] = {
    MessageData_NONE,
    MessageData_ObjectUpdate,
    MessageData_GlobalState,
    MessageData_PeerAnnounce
  };
  return values;
}

inline const char * const *EnumNamesMessageData() {
  static const char * const names[5] = {
    "NONE",
    "ObjectUpdate",
    "GlobalState",
    "PeerAnnounce",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageData(MessageData e) {
  if (::flatbuffers::IsOutRange(e, MessageData_NONE, MessageData_PeerAnnounce)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageData()[index];
}

template<typename T> struct MessageDataTraits {
  static const MessageData enum_value = MessageData_NONE;
};

template<> struct MessageDataTraits<NetworkSim::ObjectUpdate> {
  static const MessageData enum_value = MessageData_ObjectUpdate;
};

template<> struct MessageDataTraits<NetworkSim::GlobalState> {
  static const MessageData enum_value = MessageData_GlobalState;
};

template<> struct MessageDataTraits<NetworkSim::PeerAnnounce> {
  static const MessageData enum_value = MessageData_PeerAnnounce;
};

bool VerifyMessageData(::flatbuffers::Verifier &verifier, const void *obj, MessageData type);
bool VerifyMessageDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct Vec3 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Vec3Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X, 4) &&
           VerifyField<float>(verifier, VT_Y, 4) &&
           VerifyField<float>(verifier, VT_Z, 4) &&
           verifier.EndTable();
  }
};

struct Vec3Builder {
  typedef Vec3 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(Vec3::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Vec3::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(Vec3::VT_Z, z, 0.0f);
  }
  explicit Vec3Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Vec3> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Vec3>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Vec3> CreateVec3(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f) {
  Vec3Builder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct ObjectUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTID = 4,
    VT_POSITION = 6,
    VT_VELOCITY = 8,
    VT_SCALE = 10,
    VT_OWNER = 12
  };
  int32_t objectId() const {
    return GetField<int32_t>(VT_OBJECTID, 0);
  }
  const NetworkSim::Vec3 *position() const {
    return GetPointer<const NetworkSim::Vec3 *>(VT_POSITION);
  }
  const NetworkSim::Vec3 *velocity() const {
    return GetPointer<const NetworkSim::Vec3 *>(VT_VELOCITY);
  }
  const NetworkSim::Vec3 *scale() const {
    return GetPointer<const NetworkSim::Vec3 *>(VT_SCALE);
  }
  int32_t owner() const {
    return GetField<int32_t>(VT_OWNER, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OBJECTID, 4) &&
           VerifyOffset(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           VerifyOffset(verifier, VT_VELOCITY) &&
           verifier.VerifyTable(velocity()) &&
           VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyTable(scale()) &&
           VerifyField<int32_t>(verifier, VT_OWNER, 4) &&
           verifier.EndTable();
  }
};

struct ObjectUpdateBuilder {
  typedef ObjectUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_objectId(int32_t objectId) {
    fbb_.AddElement<int32_t>(ObjectUpdate::VT_OBJECTID, objectId, 0);
  }
  void add_position(::flatbuffers::Offset<NetworkSim::Vec3> position) {
    fbb_.AddOffset(ObjectUpdate::VT_POSITION, position);
  }
  void add_velocity(::flatbuffers::Offset<NetworkSim::Vec3> velocity) {
    fbb_.AddOffset(ObjectUpdate::VT_VELOCITY, velocity);
  }
  void add_scale(::flatbuffers::Offset<NetworkSim::Vec3> scale) {
    fbb_.AddOffset(ObjectUpdate::VT_SCALE, scale);
  }
  void add_owner(int32_t owner) {
    fbb_.AddElement<int32_t>(ObjectUpdate::VT_OWNER, owner, 0);
  }
  explicit ObjectUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectUpdate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectUpdate> CreateObjectUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t objectId = 0,
    ::flatbuffers::Offset<NetworkSim::Vec3> position = 0,
    ::flatbuffers::Offset<NetworkSim::Vec3> velocity = 0,
    ::flatbuffers::Offset<NetworkSim::Vec3> scale = 0,
    int32_t owner = 0) {
  ObjectUpdateBuilder builder_(_fbb);
  builder_.add_owner(owner);
  builder_.add_scale(scale);
  builder_.add_velocity(velocity);
  builder_.add_position(position);
  builder_.add_objectId(objectId);
  return builder_.Finish();
}

struct GlobalState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GlobalStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTEP = 4,
    VT_GRAVITYON = 6,
    VT_REVERSEGRAVITY = 8,
    VT_INTEGRATIONMETHOD = 10,
    VT_SCENARIOID = 12
  };
  float timestep() const {
    return GetField<float>(VT_TIMESTEP, 0.0f);
  }
  bool gravityOn() const {
    return GetField<uint8_t>(VT_GRAVITYON, 0) != 0;
  }
  bool reverseGravity() const {
    return GetField<uint8_t>(VT_REVERSEGRAVITY, 0) != 0;
  }
  int32_t integrationMethod() const {
    return GetField<int32_t>(VT_INTEGRATIONMETHOD, 0);
  }
  int32_t scenarioId() const {
    return GetField<int32_t>(VT_SCENARIOID, -1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_TIMESTEP, 4) &&
           VerifyField<uint8_t>(verifier, VT_GRAVITYON, 1) &&
           VerifyField<uint8_t>(verifier, VT_REVERSEGRAVITY, 1) &&
           VerifyField<int32_t>(verifier, VT_INTEGRATIONMETHOD, 4) &&
           VerifyField<int32_t>(verifier, VT_SCENARIOID, 4) &&
           verifier.EndTable();
  }
};

struct GlobalStateBuilder {
  typedef GlobalState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_timestep(float timestep) {
    fbb_.AddElement<float>(GlobalState::VT_TIMESTEP, timestep, 0.0f);
  }
  void add_gravityOn(bool gravityOn) {
    fbb_.AddElement<uint8_t>(GlobalState::VT_GRAVITYON, static_cast<uint8_t>(gravityOn), 0);
  }
  void add_reverseGravity(bool reverseGravity) {
    fbb_.AddElement<uint8_t>(GlobalState::VT_REVERSEGRAVITY, static_cast<uint8_t>(reverseGravity), 0);
  }
  void add_integrationMethod(int32_t integrationMethod) {
    fbb_.AddElement<int32_t>(GlobalState::VT_INTEGRATIONMETHOD, integrationMethod, 0);
  }
  void add_scenarioId(int32_t scenarioId) {
    fbb_.AddElement<int32_t>(GlobalState::VT_SCENARIOID, scenarioId, -1);
  }
  explicit GlobalStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GlobalState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GlobalState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GlobalState> CreateGlobalState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float timestep = 0.0f,
    bool gravityOn = false,
    bool reverseGravity = false,
    int32_t integrationMethod = 0,
    int32_t scenarioId = -1) {
  GlobalStateBuilder builder_(_fbb);
  builder_.add_scenarioId(scenarioId);
  builder_.add_integrationMethod(integrationMethod);
  builder_.add_timestep(timestep);
  builder_.add_reverseGravity(reverseGravity);
  builder_.add_gravityOn(gravityOn);
  return builder_.Finish();
}

struct PeerAnnounce FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PeerAnnounceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PEERID = 4,
    VT_PORT = 6
  };
  int32_t peerId() const {
    return GetField<int32_t>(VT_PEERID, 0);
  }
  int32_t port() const {
    return GetField<int32_t>(VT_PORT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PEERID, 4) &&
           VerifyField<int32_t>(verifier, VT_PORT, 4) &&
           verifier.EndTable();
  }
};

struct PeerAnnounceBuilder {
  typedef PeerAnnounce Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_peerId(int32_t peerId) {
    fbb_.AddElement<int32_t>(PeerAnnounce::VT_PEERID, peerId, 0);
  }
  void add_port(int32_t port) {
    fbb_.AddElement<int32_t>(PeerAnnounce::VT_PORT, port, 0);
  }
  explicit PeerAnnounceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PeerAnnounce> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PeerAnnounce>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PeerAnnounce> CreatePeerAnnounce(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t peerId = 0,
    int32_t port = 0) {
  PeerAnnounceBuilder builder_(_fbb);
  builder_.add_port(port);
  builder_.add_peerId(peerId);
  return builder_.Finish();
}

struct Message FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_DATA_TYPE = 6,
    VT_DATA = 8
  };
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  NetworkSim::MessageData data_type() const {
    return static_cast<NetworkSim::MessageData>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const NetworkSim::ObjectUpdate *data_as_ObjectUpdate() const {
    return data_type() == NetworkSim::MessageData_ObjectUpdate ? static_cast<const NetworkSim::ObjectUpdate *>(data()) : nullptr;
  }
  const NetworkSim::GlobalState *data_as_GlobalState() const {
    return data_type() == NetworkSim::MessageData_GlobalState ? static_cast<const NetworkSim::GlobalState *>(data()) : nullptr;
  }
  const NetworkSim::PeerAnnounce *data_as_PeerAnnounce() const {
    return data_type() == NetworkSim::MessageData_PeerAnnounce ? static_cast<const NetworkSim::PeerAnnounce *>(data()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP, 8) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyMessageData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const NetworkSim::ObjectUpdate *Message::data_as<NetworkSim::ObjectUpdate>() const {
  return data_as_ObjectUpdate();
}

template<> inline const NetworkSim::GlobalState *Message::data_as<NetworkSim::GlobalState>() const {
  return data_as_GlobalState();
}

template<> inline const NetworkSim::PeerAnnounce *Message::data_as<NetworkSim::PeerAnnounce>() const {
  return data_as_PeerAnnounce();
}

struct MessageBuilder {
  typedef Message Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(Message::VT_TIMESTAMP, timestamp, 0);
  }
  void add_data_type(NetworkSim::MessageData data_type) {
    fbb_.AddElement<uint8_t>(Message::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(::flatbuffers::Offset<void> data) {
    fbb_.AddOffset(Message::VT_DATA, data);
  }
  explicit MessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Message> CreateMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t timestamp = 0,
    NetworkSim::MessageData data_type = NetworkSim::MessageData_NONE,
    ::flatbuffers::Offset<void> data = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline bool VerifyMessageData(::flatbuffers::Verifier &verifier, const void *obj, MessageData type) {
  switch (type) {
    case MessageData_NONE: {
      return true;
    }
    case MessageData_ObjectUpdate: {
      auto ptr = reinterpret_cast<const NetworkSim::ObjectUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageData_GlobalState: {
      auto ptr = reinterpret_cast<const NetworkSim::GlobalState *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageData_PeerAnnounce: {
      auto ptr = reinterpret_cast<const NetworkSim::PeerAnnounce *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessageData(
        verifier,  values->Get(i), types->GetEnum<MessageData>(i))) {
      return false;
    }
  }
  return true;
}

inline const NetworkSim::Message *GetMessage(const void *buf) {
  return ::flatbuffers::GetRoot<NetworkSim::Message>(buf);
}

inline const NetworkSim::Message *GetSizePrefixedMessage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<NetworkSim::Message>(buf);
}

inline bool VerifyMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<NetworkSim::Message>(nullptr);
}

inline bool VerifySizePrefixedMessageBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<NetworkSim::Message>(nullptr);
}

inline void FinishMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NetworkSim::Message> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<NetworkSim::Message> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace NetworkSim

#endif  // FLATBUFFERS_GENERATED_NETWORKMESSAGES_NETWORKSIM_H_
